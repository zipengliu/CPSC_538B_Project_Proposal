\section{Distributed State}
\label{sec:distributed-state}


Distributed systems have complex state. Each node communicating in a network
relies upon its state to enact a protocol, or perform distributed computation.
Reasoning about distributed state is difficult due to asynchrous execution. In
order to develop correct systems, state must be understood. Differet aspects of
distributed state contain important information for understanding a systems
behaviour. In particular a complete set of variable values for all nodes in a
system is useful for debugging. Inherent to distributed systems is their
concurrent execution, which leads to a fundemental lack of clock
syncronization. Without synchronization, determining the precise values of a
systems variables at a moment in time is impossible. Distributed snaphosts
provide an aproximate view of a distributed system, which can be used to reason
about and understand distributed state. For instance snapshots are useful for
determining global predicates, and inferring the invariants of a systems
exeuction. Unfortunatly interpeting snapshots is difficult, they are composed
of partially ordered events, and can extend over large periods of real time.

We propose a set of techniques for extracting important information from
distributed snapshots, and aggregating information from them, into meaningful
visualizations. First, we apply a novel differentation function to distributed
snapshots which constructs an implicit finite state machine from an execution.
Second we leverage know techniques for build a communication graph, and runtime
invariants. For each of these we encode them into meaningful visualization
which can help developer understand their systems, and detect deviant
behaviour.

\subsection{State Differentiation}

Distributed state is inherently more complicatate than the state of an
individual process. However, due to the conventions of typical system designs,
state can behave predictably. For example, most distributed systems are built
using protocol specifications which define a finite state machines for the
systems behaviour. The state of instantiated systems follow the logic of their
protocols, and the state of the system is altered accordingly. Our primary
contribution of this work is a state differentiation technique which extracts
protocol specific behavior from the logs of a distributed system.

\subsubsection{System Instrumentation}

In order to extract the state of a distributed system it's variables must be
logged. We use Dinv, a tool for detecting likely data invariants in distributed
systems as an insturmentation tool. Dinv insturments systems by generating
logging code to the entrance and exit of each function in a progam. Dinv uses
program slicing to determing which variables affect, or are affected by
messages passed over a network. Each logging function contains the set of all
in scope network affected variables. Such variables are more likely to contain
state pertentat to a protocols implementation. At runtime the values of
variables in the logging statements are written to disk, along with vector
clocks, which Dinv maintians in the backgroud.

\subsubsection{Distributed Snapshot Collection}

Collecting snapshots is done on the logs generated by executing an insturmented
system. We once again leverage Dinv to compute distribued snapshots from these
logs. The complete set of distributed snapshots is a partially ordered
collection of system states. Each snapshot contains the state of each node in
the system, and the values of their vairables at the time the snapshot was
taken.

\subsubsection{Differentiation Algorithm}

To create a finite state machine from snapshots alone reqires that the
snapshots must be compaired with one another to determine which part of the FSM
they correspond to. Snapshots contain all network interacting variables; As
such no single function can be used to compare variables which respects the
semantics of their types. In order to compare the states of all variables
uniformly we encode them into their binary represtation. We define $v_{xor}$ to
be the result of calculating the xor of two variables. Each snapshot contains
variable instances, the first step in our differentation algorithm is to
compute $v_{xor}$ on each variable, with its occurance in each snapshot.


Formally a node $n$ in a distributed system is composed of variables $V \in
v_1,v_2\dots v_n$. A distributed system is composed of nodes $N \in n_1, n_2,
\dots , n_m$. A snapshot $s$ is a $n x m$ matrix

$s_{m,n} = $
$\begin{pmatrix}
  v_{1,1} & v_{1,2} & \cdots & v_{1,n} \\
  v_{2,1} & v_{2,2} & \cdots & v_{2,n} \\
  \vdots  & \vdots  & \ddots & \vdots  \\
  v_{m,1} & v_{m,2} & \cdots & v_{m,n} 
 \end{pmatrix}$

Finally $C$ is a partially ordered collection of snapshots $s_1, s_2, \dots s_k$ from a systems execution. Computing xor on two snapshots $i,j$ results in the matrix 
$s^{xor}_{i,j} = $
$\begin{pmatrix}
  xor(v_{i1,1},v_{j1,1}}) & xor(v_{i1,2},v_{j1,2}}) & \cdots & xor(v_{i1,n},v_{j1,n}}) \\
  xor(v_{i2,1},v_{j2,1}}) & xor(v_{i2,2},v_{j2,2}}) & \cdots & xor(v_{i2,n},v_{j2,n}}) \\
  \vdots  & \vdots  & \ddots & \vdots  \\
  xor(v_{im,1},v_{jm,1}}) & xor(v_{im,2},v_{jm,2}}) & \cdots & xor(v_{im,n},v_{jm,n}}) \\
 \end{pmatrix}$

We constuct a $k$ x $k$ plane $P^{xor}$ where $\forall i,j \in C, P^{xor}_{i,j} =
s^{xor}_{i,j}$.

Each $v_{xor}$ is a binary string where each 1 bit corresponds to a difference
in bit correspondece between two variable instances. To construct a difference
measure between the two variables we compute the hamming weight of each
$v_{xor}$ by counting it's one bits, denoted $v_{hw}$ which reduces each
variable to a single integer. The next step in the algorithm is to compute
$v_{hm} \forall v_{xor} \in P$ denoted $P^{hm}$. Each index in $P^{hm}$ is a
vector of values. The final step in our state differentiation algorithm is to
reduce each vector in $P^{hm}$ to a single value representing the difference in
state between two snapshots. This is done by computing the euclidean norm of
each vector. Formally we compute $P^n$ where $\forall i,j \$P^{hm}, P^n_{i,j} = \sqrt{(P^{hm}_{i,j,1})^2 + (P^{hm}_{i,j,2})^2 +\dots + (P^{hm}_{i,j,n})^2 }$













